### 15/10
!This could have broken things! All files in ai_common decompiled without crashing and appear correct at a glance.

- MergeConditionalAssignments. Only removes 1 instruction if it finds a pattern match now. Reason: other parts of the code can be using the labels here, such as in `return log.logs[name] == true or log.on == false;` where `log.logs[name] == true` will be using the first label as well.
- Function arguments are now renamed to f{DebugID}_arg{index}. Reason: Function arguments can be used as upvalues, can create name conflicts with nested functions. Allow for easy mass repacing that only affects 1 function in text editors.
- Added UnlinkIrrelevantEmptyBlocks pass to eliminate any blocks with no instructions whose successor is the adjacent block in the BlockList. Reason: PerformExpressionPropogation can leave empty blocks in the middle of the flow. Example:
From Gunda_battle.lua listing created by luac
```lua
	104	[-]	SELF     	8 1 281	; "GetHpRate"
	105	[-]	GETGLOBAL	10 9	; TARGET_SELF
	106	[-]	CALL     	8 3 2
	107	[-]	LE       	0 8 282	; - 0.55
	108	[-]	JMP      	0 18	; to 127
	109	[-]	SELF     	8 1 256	; "GetNpcThinkParamID"
	110	[-]	CALL     	8 2 2
	111	[-]	EQ       	1 8 257	; - 511100
	112	[-]	JMP      	0 1	; to 114
	113	[-]	LOADBOOL 	8 0 1
	114	[-]	LOADBOOL 	8 1 0
	115	[-]	LOADBOOL 	9 0 0
	116	[-]	EQ       	0 8 9
	117	[-]	JMP      	0 9	; to 127
	118	[-]	SELF     	8 1 258	; "HasSpecialEffectId"
	119	[-]	GETGLOBAL	10 9	; TARGET_SELF
	120	[-]	LOADK    	11 33	; 5404
	121	[-]	CALL     	8 4 2
	122	[-]	LOADBOOL 	9 0 0
	123	[-]	EQ       	0 8 9
	124	[-]	JMP      	0 2	; to 127
	125	[-]	SETTABLE 	3 284 267	; 50 100
	126	[-]	JMP      	0 206	; to 333
	127	[-]	SELF     	8 1 281	; "GetHpRate"
	128	[-]	GETGLOBAL	10 9	; TARGET_SELF
	129	[-]	CALL     	8 3 2
	130	[-]	LT       	0 8 285	; - 0.65
	131	[-]	JMP      	0 13	; to 145
	132	[-]	SELF     	8 1 256	; "GetNpcThinkParamID"
	133	[-]	CALL     	8 2 2
	134	[-]	EQ       	0 8 257	; - 511100
	135	[-]	JMP      	0 9	; to 145
	136	[-]	SELF     	8 1 258	; "HasSpecialEffectId"
	137	[-]	GETGLOBAL	10 9	; TARGET_SELF
	138	[-]	LOADK    	11 10	; 5020
	139	[-]	CALL     	8 4 2
	140	[-]	LOADBOOL 	9 0 0
	141	[-]	EQ       	0 8 9
	142	[-]	JMP      	0 2	; to 145
	143	[-]	SETTABLE 	3 286 267	; 30 100
	144	[-]	JMP      	0 188	; to 333
```
Or in plain lua: 
```lua
  if ai:GetHpRate(TARGET_SELF) > 0.55 == false and ai:GetNpcThinkParamID() ~= 511100 and ai:HasSpecialEffectId(TARGET_SELF, 5404) == false then
		oddsTbl[50] = 100
	elseif...
```
`ai:GetHpRate(TARGET_SELF) > 0.55 == false` will be succeeded by an empty block, then the `ai:GetNpcThinkParamID() ~= 511100` and then the  `ai:HasSpecialEffectId(TARGET_SELF, 5404) == false`. This breaks the following call StructureCompoundConditionals from linking all of these 3 together into 1 condition and produces incorrect code removing the latter entirely and producing an empty if branch body after the condition `ai:GetHpRate(TARGET_SELF) > 0.55 == false`. This will also cause it to crash cos ConvertToAST doesn't expect empty blocks within ifs.
This seems to be the cause of similar evil in zz_util:
```lua
function Birdteam:ShouldIWait( ai )

	local myIdx = self[ ai:GetNpcThinkParamID() ].moveIdx;
	local friIdx = self[ self:GetFriendThinkId( ai ) ].moveIdx;
	
	if ( myIdx ~= friIdx ) then
		return myIdx > friIdx;
	end
	
	return ai:GetDist( POINT_EVENT ) <= ai:GetDistAtoB( POINT_EVENT, TARGET_FRI_0 );
	
end
```
This is basically exact same issue as with Gunda_battle. if (myIdx ~= friIdx)... condition has 2 successors, both point to empty blocks, and the empty blocks point to the correct return blocks. Following processing functions don't expect empty blocks and crash. If relinking works properly then this should be working correctly.

### 14/10
Upvalues seem to work (ds3) now but only checked against ai_common archive. common_battle_func decompiles properly and that has like a billion closures and upvalues so I assume it's fine. Only 2 files don't decompile: Gunda_battle.lua (collection is empty exception) and zz_util.lua (collection is empty).

- Added a return statement if the program throws when parsing args. Reason: Crash if no arguments provided.
- GenerateIR50. Upvalue related instructions generated by CLOSURE instruction will now save the DebugID of the function they belong to. Reason: Easily find them later and handle separately from everything else. Technically it would be best to add them directly to the dictionary and not the list but... maybe another day, this would also render any changes to EliminateRedundantAssignments unnecessary.
- EliminateRedundantAssignments. This method will now remove all upvalue related instructions marked earlier from instructions list and add them to the UpValInst dictionary key'd by DebugID of the closure's function they belong to. Reason: These instructions are needed later for upvalue registration. Previously EliminateRedundantAssignments would just remove instructions of type MOVE 0 0/GETUPVAL 0 0 which are required to properly register upvalues. Just leaving them in would cause other issues as they shouldn't be parsed like normal MOVE/GETUPVAL instructions.
- RegisterClosureUpvalues50. Now only loops through the instructions saved in UpValInst dictionary's list that corresponds to our DebugID. Throws exception if it can't find it (should never happen since we save everything manually). No longer peeks the instruction list. Reason: Everything needed was allegedly saved in the dictionary so no need to do anything else.
